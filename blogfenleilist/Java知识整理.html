<!DOCTYPE html>
<html>
	<head>
	<meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
		<meta charset="UTF-8">
	<!-- Bootstrap -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
		

    <script src="../js/jquery-1.11.3.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/scrollReveal.js"></script>
		<title>Java知识整理</title>
		<link rel="stylesheet" href="../css/blogfeleilist.css" />
	</head>
	<body>			
			<nav class="navbar navbar-default navbar-inverse navbar-fixed-top">
					<div class="container">
  			<div class="container-fluid ">
  
   	 <!-- Brand and toggle get grouped for better mobile display -->
   				 <div class="navbar-header">
     		 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
     
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li class="active"><a href="a.html">JAVA</a></li>
        <li><a href="b.html"></a>DATABASE</li>
        <li><a href="c.html">LINUX</a></li>
        <li><a href="d.html">HTML5</a></li>
        <li><a href="e.html">C</a></li>
        <li><a href="f.html">SPRING</a></li>
        <li><a href="g.html">STRUTS</a></li>
        <li><a href="h.html">HIBEINATE</a></li>
        <li><a href="i.html">BOOTSTRAP</a></li>
          </ul>
        </li>
      </ul>
    
      <ul class="nav navbar-nav navbar-right">
        <li><a href="j.html">BOOK</a></li>
        <li><a href="zhuye.html">BACK</a></li>
        <li><a href="zhuye.html?#contact">CONTACT ME</a></li>
        </li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
		</div>
			</nav>
		<div id="mainmianban">
			<h1>Java知识回顾</h1>
			<p>最近在看一些工程代码，于是看了看<span class='wp_keywordlink_affiliate'><a  href="http://www.amazon.cn/gp/product/B001130JN8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&#038;tag=importnew-23&#038;linkCode=as2&#038;camp=536&#038;creative=3200&#038;creativeASIN=B001130JN8" title="设计模式:可复用面向对象软件的基础" rel="nofollow" target="_blank" class="external">设计模式</a></span>，看设计模式之前发现Java是先修知识，又重新补了一遍Java，温故知新，获得一些新的体会。<br />
本文不打算作为“Java知识点详细梳理”，“10分钟学会Java”之类的文章，仅作为博主自己的一个回顾，涉及的内容也无定法。</p>
<p>Java应该是目前用的最多的编程语言，以前觉得Java老要点点点（调用方法），变量名也很长，C++/Python很少代码写完的东西Java可能要写很多行……<br />
觉得挺麻烦的，不过Java风靡自有其风靡的理由，在面向对象语言中她是一个标杆，虽然繁琐，但比较清晰，比较简单。</p>
<p>拿变量类型来说，Java只有两种变量类型，primitive主数据类型和引用数据类型。</p>
<p>Java中最关键的概念是面向对象，面向对象最关键的东西就是类和对象，所有的Java程序都定义在类中，你不能像python那样，打开.py文件就开始写东西，就可以执行了，也不像C++，定义一个main函数即可运行。在Java中即使main函数也要包括在类中。</p>
<p>为什么面向对象是核心内容？它的好处在哪呢？可以说，OO(面向对象)无处不在，OO使得我们很方便的扩展功能，而不需要重复写很多代码！另外，OO的设计思想其实是抽象思维的一种体现，它改变了我们设计程序的方式，我们不再是根据程序需要什么功能就开始从头到尾实现什么功能，我们更多考虑的是类和对象，程序包含几种类型的实体？有什么共同点？可以进行怎样的抽象？用继承还是接口？……</p>
<p>说说类和对象，类是对象的模板，类定义好“像我这样的人应该有什么状态，特征，能够做到那些事”，而对象具体化了类，真正获得了具体的状态，具体的特征，以及做某些事的方法。</p>
<p>我们说到，Java只有两种变量，primitive主数据类型和引用数据类型。主数据类型包括我们所指的int,double,float等等，这些不是对象。而引用变量是一个到对象的引用，相当于一个遥控器，指向堆上的某个对象，通过此引用可以获得对象，重新赋值此引用并不改变对象，只是引用指到了另一个对象上而已。没有对象变量，只有指向对象的引用变量。<br />
==: 比较primitive主数据类型是否相同，或两个引用是否指向同一对象</p>
<p>话题回到面向对象，提到面向对象，不得不提其三大特性，这也是面试中经常会问到的，即封装，继承和多态。</p>
<ul>
<li><strong>封装(encapsulation)</strong>，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；</li>
<li><strong>多态(polymorphism)</strong>，一句话，“接口的多种不同的实现方式即为多态”，但是这个不太好理解，甚至我觉得它不够准确，因为光说接口是不是有点不够？换一种说法，多态即允许将子类对象的引用赋值给父类对象的引用，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。因为：编译器根据引用类型来判断可以调用哪些方法，而不是根据确实的类型。</li>
<li><strong>继承(inheritance)</strong> 是指一个对象直接使用另一对象的属性和方法，很简单，父类是球，子类是足球，那么足球可以直接使用“滚动”这个方法，如果需要特殊的“滚”，那子类自己实现就好了。</li>
</ul>
<p>之所以继承放在最后讲，是因为我们关于继承有更多要说的。</p>
<p>【继承方法调用时的最近原则】调用对象引用的方法时，会调用到与该对象类型最接近的方法，就是说如果子类实现了某继承的方法，那就调用子类的，如果没有实现，那就往上找最近的实现的类的方法。</p>
<p>继承的IS-A测试，即“足球”IS-A“球”，总得满足这样的关系才好说继承，就像你不太好意思继承隔壁王叔叔财产。</p>
<p>继承的意义何在？这是显然的，首先避免了大量重复的程序代码，其次可以定义出一组共同的协议，所有继承者都需要满足这个协议，你知道，在很多时候大家遵守一些共同的规则是很重要的。</p>
<p>继承的一些使用建议：<br />
1） 当某个类会比其父类更具有特定意义时使用继承<br />
2）行为程序需要被多个相同基本类型的类共享时，考虑使用继承<br />
3）集成并不一定是达成重用行为程序的最佳方式，具体可参见设计模式<br />
4）继承结构并不匹配两者的关系，不要用继承<br />
5）不能通过IS-A测试一定不要用继承</p>
<p>如果最高的父类不能抽象出一些对所有族类都使用的方法，或者不太好初始化，比如你不好新建一个“球”对象，它是啥球呢？地球还是足球？这样一些情况我们可以定义抽象类，它不能被初始化，只能被继承。。抽象类中可以定义抽象方法，抽象方法只存在于抽象类中，一个类只要有一个抽象方法，那他必是抽象类。</p>
<p>有时候，你会想要继承多个父类，以便使用更多的已有代码，但是不幸的是Java并不支持多重继承，要多重继承请关闭本文，搜索”C++”关键词谢谢。</p>
<p>为啥不支持多重继承呢？因为存在多重继承（继承多个类）的“致命方块”问题，即如果两个父类继承自同一个祖父类，都实现了某个方法，那么子类（如果没有实现该方法）该调用那个版本？</p>
<p>解决“致命方块”问题？接口！</p>
<p>接口是100%纯抽象类，每个方法都是抽象的，必须被实现。</p>
<p>如果想要定义出类可以扮演的角色，使用接口。</p>
<p>接下来从生物学的角度谈谈对象？什么是生物学角度？？即生老病死~</p>
<p>对象生存在堆上（可以理解为垃圾堆，随时可能有人来回收…），引用变量或局部变量生存在栈上。</p>
<p>一旦一个对象，它的引用没有了或者离弃了它，那么他就可以等待被回收了。Java有一套垃圾回收机制(GC)保证对象的回收来腾出堆空间，有时候，GC又常常被人诟病，在大数据应用中常常面临这大量的shuffle，大量的对象，有时候需要花费大量的时间来做GC，体验不佳。</p>
<p>总的来说，对象的出生靠调用构造函数，生存在堆上，一旦没了引用，就向生命的终点走去，直到GC（黑白无常）带走了它。。</p>
<p>新建对象时，父类的构造函数先于子类被调用，以此类推，Object的构造函数先被执行，然后往下推，直到目标对象类型<br />
（先有父母才有你）<br />
只有当完全没写构造函数时，Java才会自动帮你写一个无参构造函数。<br />
super()调用父类的构造函数，this是对对象本身的引用</p>
<p>谈谈实例变量，实例变量即对象的成员变量。</p>
<p>JAVA的实例变量具有如下特点：<br />
1）实例变量声明在一个类中，但在方法、构造方法和语句块之外；<br />
2）当一个对象被实例化之后，每个实例变量的值就跟着确定；<br />
3）实例变量在对象创建的时候创建，在对象被销毁的时候销毁；<br />
4）实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；<br />
5）实例变量可以声明在使用前或者使用后；<br />
6）访问修饰符可以修饰实例变量；<br />
7）实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；<br />
8）实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</p>
<p>你可能想问，如果Java中只有对象和primitive主数据类型，那么我想定义全局变量或者常量怎么办？比如PI=3.141592653589..(后面忘了)<br />
这时候，静态变量可以帮你。静态变量定义在类中，它属于类，不属于任何对象，但对象可以获得它。<br />
类的静态变量由（该类的）所有对象所共享。<br />
静态方法通过类名调用，静态变量通过类名存取 。<br />
如果类只有静态方法，则可以将构造函数标记为private的，以免被初始化</p>
<p>Java常量 = final static 的变量<br />
final意味着不能被改变，static意味着是静态变量。</p>
<p>插一句字符串的格式化：<br />
String.format(格式化说明)<br />
格式化说明包括5部分，%和type是必要的<br />
%[argument number] [flags] [width] [.precision] type<br />
如： %,6.1f 为6位逗号分隔，1位小数的浮点数</p>
<p>谈谈异常吧，谁能保证自己的程序不出问题呢？与其系统运行的时候报一大堆乱七八糟的错误trace，早早地预见并处理一下，以自己的方式处理或者打印它，总要漂亮些吧？甚至可以在抓到异常后，给出“没关系，一个小错误，已经报告给开发者~”这样温和的语句，是不是显得b格很高？……<br />
异常中要注意的点有：<br />
可能会抛出异常的方法必须声明成throws Exception<br />
catch捕获多个异常时，要从小排到大，因为大异常后面的小异常根本没有被catch的机会<br />
在方法后加上throws xxException，没有try/catch块，表示可能会抛出异常，自己并不处理，需要调用方自己处理异常<br />
所以&gt;&gt;&gt;要么处理，要么声明（异常）</p>
<p>序列化对象：有时候需要保存一下对象，以便于恢复，被调用，而不用重新生成，因为生成过程可能很麻烦。<br />
要序列化的话，对象必须可序列化，且对象中实例变量所引用的对象甚至对象引用的对象…都必须可以序列化，简而言之，整个对象版图都必须可以序列化<br />
如果某实例变量不需要或者不能被序列化，那可以把它标记为transient（瞬时）的。<br />
解序列化时，transient变量会恢复成null对象引用或者0,false等primitive默认值<br />
静态变量不会被序列化，对象被还原时，静态变量会维持类中原本的样子。因为所有对象共用一份静态变量。<br />
读取对象的顺序必须与写入的顺序相同</p>
<p>序列化对象：</p>
<pre class="brush: java; gutter: true">FileOutputStream fileStream = new FileOutputStream(&quot;MySer.ser&quot;)
ObjectOutputStream os = new ObjectOutputStream(fileStream)
os.writeObject(obj)
os.close()</pre>
<p>或者不序列化，而是将信息写入文本文件：</p>
<pre class="brush: java; gutter: true">BufferedWriter writer = new BufferedWriter(new FileWriter(file))  // file is a File object
writer.write(...)</pre>
<p>可以把File想象成文件的路径，代表磁盘上的某个文件，但并不是文件内容</p>
<pre class="brush: java; gutter: true">BufferedWriter writer = new BufferedWriter(new FileWriter(file))  // file is a File object</pre>
<p>这句代码形成如下链接：</p>
<pre class="brush: java; gutter: true">字符串 --&gt; BufferedWriter --&gt; FileWriter --&gt; File</pre>
<p>对象序列化以后，类继续演进，这时会出现无法还原的情况。通过将serialVersionUID放在class中，让类在演化过程中维持同样的ID，可以保证还原的时候能够识别，从而正确还原出对象。但要注意有些修改会损害解序列化。</p>
		</div>
<script>
if (!(/msie [6|7|8|9]/i.test(navigator.userAgent))){
		(function(){
		window.scrollReveal = new scrollReveal({reset: true});
	})();
};
$('#myTab a').click(function (e) {
  e.preventDefault();
  $(this).tab('show');
})

$('a[data-toggle="tab"]').on('shown', function (e) {
  e.target // activated tab
  
})
 
</script>
	</body>
</html>
	</body>
</html>
